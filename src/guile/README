
                        Scheme Scripting
                        ----------------

                    Linas Vepstas, May 2008


This directory contains an implementation of the a Scheme shell for the
OpenCog server.  Scheme is a dialect of Lisp; the shell allows scheme
code to manipulate the contents of an OpenCog AtomSpace. The shell
may be invoked by typing "scm" at the opencog prompt. To leave the shell,
place a single . on the line, and hit enter. Alternately, hit ^D.
Currently, only a small number of primitives have been implemented.

This binding is intended to be used for day-to-day maintenance
activities, and for experimentation. it is not meant to be used for any
sort of serious calculation, simply because it is not (and cannot be) a
high-performance interface. The shell is implemented in guile; guile is
an interpreter, not a compiler. There is no bytecode or virtual machine.

Core Functions
--------------
The following are the "core" functions, implemented in the guile-to-C++
interface.

== cog-new-node node-type node-name
      Create a new node of the given type and name

      Optionally, a truth value can follow the node name.
      Throws errors if node-type is not a valide atom type for a node,
      and if node-name is not a string.

      Example:
          Create a new node, and prints its value:
          guile> (cog-new-node 'ConceptNode "some node name")
          #<node[3:some node name] sti:(0,0) tv:(0.000000,0.000000)>

          Creates a new node, with a truth value:
          guile> (cog-new-node 'ConceptNode "another node"
                        (cog-new-stv 0.8 0.9))
          #<node[3:another node] sti:(0,0) tv:(0.800000,0.900000)>


== cog-node node-type node-name
      Returns the node of the given type and name, if it exists, else
      returns null.

      Optionally, a truth value can follow the node name. If the node
      exists, then the truth value is modified.
      Throws errors if node-type is not a valide atom type for a node,
      and if node-name is not a string.

      Example:
          Check to see if a node exists: 
          guile> (cog-node 'ConceptNode "asdf")
          ()

          Verify that the return value is actually a true null:
          guile> (null? (cog-node 'ConceptNode "asdf"))
          #t 

          Now, create the node, and see if it exists:
          guile> (cog-new-node 'ConceptNode "asdf")
          #<node[3:asdf] sti:(0,0) tv:(0.000000,0.000000)>
          guile> (null? (cog-node 'ConceptNode "asdf"))
          #f

          Change the truth value of an existing node:
          guile> (cog-node 'ConceptNode "asdf" (cog-new-stv 0.8 0.9))
          #<node[3:some node name] sti:(0,0) tv:(0.800000,0.900000)>


== cog-new-link link-type atom ... atom
      Create a new link, with the given atoms in the link.

      Optionally, a truth value can follow the list of atoms.
      Throws errors if the link type is not a valid opencog link type,
      or if any of the arguments after the link type are not atoms.

      Example:
          Creates two nodes, and a new link:
          guile> (define x (cog-new-node 'ConceptNode "abc"))
          guile> (define y (cog-new-node 'ConceptNode "def"))
          guile> (cog-new-link 'Link x y)
          #<link[2 sti:(0,0) tv:(0.000000,0.000000) <[3 abc],[3 def]>]>

          Create a new link with a truth value:
          guile> (cog-new-link 'Link x y (cog-new-stv 0.7 0.8))
          #<link[2 sti:(0,0) tv:(0.700000,0.800000) <[3 abc],[3 def]>]>


== cog-atom handle
      Reference the atom identified by the integer-valued handle
== cog-handle atom
      Return the handle (which is an integer) of the atom

      Example:
         (define x (cog-new-node 'ConceptNode "abc"))
         (define y (cog-new-node 'ConceptNode "def"))
         (cog-handle x)
         113
         (cog-handle y)
         114
         (cog-atom 114)
         #<node[3:def] sti:(0,0) tv:(0.000000,0.000000)>
         (integer? x)
         #f
         (integer? (cog-handle x))
         #t


== cog-incoming-set atom
== cog-outgoing-set atom
      Return the incoming and outgoing sets, respectively, of the atom.

      Example:
         (define x (cog-new-node 'ConceptNode "abc"))
         (define y (cog-new-node 'ConceptNode "def"))
         (define l (cog-new-link 'Link x y))
         (cog-incoming-set x)
         (#<link[2 sti:(0,0) tv:(0.000000,0.000000) <[3 abc],[3 def]>]>)
         (cog-incoming-set y)
         (#<link[2 sti:(0,0) tv:(0.000000,0.000000) <[3 abc],[3 def]>]>)
         (equal? (cog-incoming-set x) (cog-incoming-set y))
         #t

== cog-delete atom
      Delete the indicated atom, but only if it has no incoming links.
== cog-delete-recursive atom
      Delete the incoming atom, and all atoms that point at it.

      Both functions return #t on success, else they return #f.

      Example:
         (define x (cog-new-node 'ConceptNode "abc"))
         (define y (cog-new-node 'ConceptNode "def"))
         (define l (cog-new-link 'Link x y))

         (cog-delete x)
         #f
         (cog-delete-recursive x)
         #t
         l
         Invalid handle
         x
         Invalid handle
         y
         #<node[3:def] sti:(0,0) tv:(0.000000,0.000000)>

         Note that x and the link l point to have been deleted,
         but not the link y.

== cog-new-stv mean confidence
      Create a SimpleTruthValue with the given mean and confidence.
      Unlike atoms, simple truth values are ephemeral: they are
      garbage-collected when no longer needed.

      Throws errors if mean and confidence are not floating-point
      values.
      Example:
          (cog-new-stv 0.7 0.9)


Example utilities
-----------------
Below follow some examples, in the form of utilities.

== Load scheme data from a file

To load scheme code from a file, simply make sure the first 3 characters
of the file are "scm" followed by a carraige return. Then, at the shell
prompt, simply execute the command:

  cat filename | telnet localhost 17001

This assuses the scheme code is in "filename", that the cogserver is
running on "localhost", and is listening on port 17001 (which is the
default port for the cogserver).

== Delete a list of atoms:

   (define (killall lst)
           (if (null? lst)
               '()
               (cons (cog-delete (car lst))
                     (killall (cdr lst)))))




ToDo
----
-- support readline/editline (uparrows, etc.) on input.
-- enable module loading

-- change cog-delete to also accept a list of atoms
-- change printed output so that it's valid scheme
-- change cog-delete to return nill, not #t (?why?)
-- define cog-node and cog-link to return nodes/links if they
   exist, but not create them if they don't.


