
                        Scheme Scripting
                        ----------------

                    Linas Vepstas, May 2008


This directory contains an implementation of the a Scheme shell for the
OpenCog server.  Scheme is a dialect of Lisp; the shell allows scheme
code to manipulate the contents of an OpenCog AtomSpace. The shell 
may be invoked by typing "scm" at the opencog prompt. To leave the shell,
place a single . on the line, and hit enter. Alternately, hit ^D. 
Currently, only a small number of primitives have been implemented.

This binding is intended to be used for day-to-day maintenance 
activities, and for experimentation. it is not meant to be used for any
sort of serious calculation, simply because it is not (and cannot be) a
high-performance interface. The shell is implemented in guile; guile is
an interpreter, not a compiler. There is no bytecode or virtual machine.

Functions:

   cog-new-node node-type node-name 
      Create a new node of the given type and name

      Throws errors if node-type is not a valide atom type for a node,
      and if node-name is not a string.
      Example:
          (cog-new-node 'ConceptNode "some node name")
          creates a new node, and prints its value:
          #<node[3:some node name] sti:(0,0) tv:(0.000000,0.000000)>


   cog-new-link link-type atom ... atom
      Create a new link, with the given atoms in the link.

      Throws errors if the link type is not a valid opencog link type,
      or if any of the arguments after the link type are not atoms.

      Example:
          (define x (cog-new-node 'ConceptNode "abc"))
          (define y (cog-new-node 'ConceptNode "def"))
          (cog-new-link 'Link x y)

          creates a new link, and prints it:
          #<link[2 sti:(0,0) tv:(0.000000,0.000000) <[3 abc],[3 def]>]>
      
   cog-atom handle
      Reference the atom identified by the numeric handle
   cog-handle atom
      Return the handle of the atom

      Example:
         (define x (cog-new-node 'ConceptNode "abc"))
         (define y (cog-new-node 'ConceptNode "def"))
         (cog-handle x)
         113
         (cog-handle y)
         114
         (cog-atom 114)
         #<node[3:def] sti:(0,0) tv:(0.000000,0.000000)>


   cog-incoming-set atom
   cog-outgoing-set atom
      Return the incoming and outgoing sets, respectively, of the atom.

      Example:
         (define x (cog-new-node 'ConceptNode "abc"))
         (define y (cog-new-node 'ConceptNode "def"))
         (define l (cog-new-link 'Link x y))
         (cog-incoming-set x)
         (#<link[2 sti:(0,0) tv:(0.000000,0.000000) <[3 abc],[3 def]>]>)
         (cog-incoming-set y)
         (#<link[2 sti:(0,0) tv:(0.000000,0.000000) <[3 abc],[3 def]>]>)
         (equal? (cog-incoming-set x) (cog-incoming-set y))
         #t

   cog-delete atom
      Delete the indicated atom, but only if it has no incoming links.
   cog-delete-recursive atom
      Delete the incoming atom, and all atoms that point at it.

      Both functions return #t on success, else they return #f.

      Example:
         (define x (cog-new-node 'ConceptNode "abc"))
         (define y (cog-new-node 'ConceptNode "def"))
         (define l (cog-new-link 'Link x y))

         (cog-delete x)
         #f
         (cog-delete-recursive x)
         #t
         l
         Invalid handle
         x
         Invalid handle
         y
         #<node[3:def] sti:(0,0) tv:(0.000000,0.000000)>

         Note that x and the link l point to have been deleted,
         but not the link y.


Example utilities
-----------------
Below follow some examples, in the form of utilities.

Delete a list of atoms:

   (define (killall lst)
           (if (null? lst)
               '()
               (cons (cog-delete (car lst))
                     (killall (cdr lst)))))




ToDo
----
-- add cmake scripts to auto-find guile, and build appropriately, if found.
-- implement truth values
-- pass truth values with keywords
-- support readline/editline (uparrows, etc.) on input.
-- enable module loading
-- enable file loading

-- change cog-delete to also accept a list of atoms
-- change printed output so that it's valid scheme
-- change cog-delete to return nill, not #t (?why?)
-- define cog-node and cog-link to return nodes/links if they
   exist, but not create them if they don't.


