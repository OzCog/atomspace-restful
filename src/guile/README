
                        Scheme Scripting
                        ----------------

                    Linas Vepstas, May 2008


This directory contains an implementation of the a Scheme shell for the
OpenCog server.  Scheme is a dialect of Lisp; the shell allows scheme
code to manipulate the contents of an OpenCog AtomSpace. The shell
may be invoked by typing "scm" at the opencog prompt. To leave the shell,
place a single . on the line, and hit enter. Alternately, hit ^D.
Currently, only a small number of primitives have been implemented.

This binding is intended to be used for day-to-day maintenance
activities, and for experimentation. it is not meant to be used for any
sort of serious calculation, simply because it is not (and cannot be) a
high-performance interface. The shell is implemented in guile; guile is
an interpreter, not a compiler. There is no bytecode or virtual machine.

Core Functions
--------------
The following are the "core" functions, implemented in the guile-to-C++
interface.

== cog-new-node node-type node-name
      Create a new node of the given type and name

      Optionally, a truth value can follow the node name.
      Throws errors if node-type is not a valide atom type for a node,
      and if node-name is not a string.

      Example:
          ; Create a new node, and prints its value:
          guile> (cog-new-node 'ConceptNode "some node name")
          #<node[3:some node name] sti:(0,0) tv:(0.000000,0.000000)>

          ; Creates a new node, with a truth value:
          guile> (cog-new-node 'ConceptNode "another node"
                        (cog-new-stv 0.8 0.9))
          #<node[3:another node] sti:(0,0) tv:(0.800000,0.900000)>


== cog-node node-type node-name
      Returns the node of the given type and name, if it exists, else
      returns null.

      Optionally, a truth value can follow the node name. If the node
      exists, then the truth value is modified.
      Throws errors if node-type is not a valide atom type for a node,
      and if node-name is not a string.

      Example:
          ; Check to see if a node exists: 
          guile> (cog-node 'ConceptNode "asdf")
          ()

          ; Verify that the return value is actually a true null:
          guile> (null? (cog-node 'ConceptNode "asdf"))
          #t 

          ; Now, create the node, and see if it exists:
          guile> (cog-new-node 'ConceptNode "asdf")
          #<node[3:asdf] sti:(0,0) tv:(0.000000,0.000000)>
          guile> (null? (cog-node 'ConceptNode "asdf"))
          #f

          ; Change the truth value of an existing node:
          guile> (cog-node 'ConceptNode "asdf" (cog-new-stv 0.8 0.9))
          #<node[3:some node name] sti:(0,0) tv:(0.800000,0.900000)>


== cog-new-link link-type atom ... atom
      Create a new link, with the given atoms in the link.

      Optionally, a truth value can follow the list of atoms.
      Throws errors if the link type is not a valid opencog link type,
      or if any of the arguments after the link type are not atoms.

      Example:
          ; Creates two nodes, and a new link:
          guile> (define x (cog-new-node 'ConceptNode "abc"))
          guile> (define y (cog-new-node 'ConceptNode "def"))
          guile> (cog-new-link 'Link x y)
          #<link[2 sti:(0,0) tv:(0.000000,0.000000) <[3 abc],[3 def]>]>

          ; Create a new link with a truth value:
          guile> (cog-new-link 'Link x y (cog-new-stv 0.7 0.8))
          #<link[2 sti:(0,0) tv:(0.700000,0.800000) <[3 abc],[3 def]>]>

== cog-link link-type atom ... atom
      Returns the link of the given type and list of atoms, if it
      exists, else returns null.

      Optionally, a truth value can follow the list of atoms. If the
      link exists, then the truth value is modified.

      Throws errors if the link type is not a valid opencog link type,
      or if any of the arguments after the link type are not atoms.

      Example:
          ; Create two nodes:
          guile> (define x (cog-new-node 'ConceptNode "abc"))
          guile> (define y (cog-new-node 'ConceptNode "def"))

          ; Does a node with these two links exist?
          guile> (cog-link 'Link x y)
          ()

          ; Now, create such a link
          guile> (cog-new-link 'Link x y)
          #<link[2 sti:(0,0) tv:(0.000000,0.000000) <[3 abc],[3 def]>]>

          ; Check again for existence:
          guile> (cog-link 'Link x y)
          #<link[2 sti:(0,0) tv:(0.000000,0.000000) <[3 abc],[3 def]>]>

          ; Change the truth value of an existing node:
          guile> (cog-link 'Link x y (cog-new-stv 0.7 0.8))
          #<link[2 sti:(0,0) tv:(0.700000,0.800000) <[3 abc],[3 def]>]>


== cog-delete atom
      Delete the indicated atom, but only if it has no incoming links.
== cog-delete-recursive atom
      Delete the incoming atom, and all atoms that point at it.

      Both functions return #t on success, else they return #f.
      If #f is returned, then the delete failed.

      Example:
         ; Define two nodes and a link between them:
         guile> (define x (cog-new-node 'ConceptNode "abc"))
         guile> (define y (cog-new-node 'ConceptNode "def"))
         guile> (define l (cog-new-link 'Link x y))

         ; Verify that there's an atom called x:
         guile> x
         #<node[3:abc] sti:(0,0) tv:(0.000000,0.000000)>

         ; Try to delete x. This should fail, since there's a link
         ; containing x. 
         guile> (cog-delete x)
         #f

         ; Delete x, and everything pointing to it. This should delete
         ; both x, and the link l.
         guile> (cog-delete-recursive x)
         #t

         ; Verify that the link l is gone:
         guile> l
         Invalid handle

         ; Verify that the node x is gone:
         guile> x
         Invalid handle

         ; Verify that the node y still exists:
         guile> y
         #<node[3:def] sti:(0,0) tv:(0.000000,0.000000)>


== cog-atom? exp
      Return #t if exp is an atom, else return #f

      Example:
         ; Define a node
         guile> (define x (cog-new-node 'ConceptNode "abc"))
         guile> (define y (+ 2 2))
         guile> (cog-atom? x)
         #t
         guile> (cog-atom? y)
         #f


== cog-name atom
      Return the name of the node. If the atom is not a node, 
      returns NIL.

      Example:
         ; Define a node
         guile> (define x (cog-new-node 'ConceptNode "abc"))
         guile> (cog-name x)
         "abc"


== cog-type atom
      Return the type of the atom. 

      Example:
         ; Define a node
         guile> (define x (cog-new-node 'ConceptNode "abc"))
         guile> (cog-type x)
         ConceptNode
         guile> (eq? 'ConceptNode (cog-type x))
         #t

== cog-arity atom
      Return the arity of the atom.

      Example:
         guile> (define x (cog-new-node 'ConceptNode "abc"))
         guile> (cog-arity x)
         0
         guile> (define l (cog-new-link 'Link x x x))
         guile> (cog-arity l)
         3


== cog-incoming-set atom
== cog-outgoing-set atom
      Return the incoming and outgoing sets, respectively, of the atom.
      These sets are returned as ordinary scheme lists.

      Example:
         ; Define two nodes and a link between them:
         guile> (define x (cog-new-node 'ConceptNode "abc"))
         guile> (define y (cog-new-node 'ConceptNode "def"))
         guile> (define l (cog-new-link 'Link x y))

         ; Get the incoming sets of nodes x and y (which is the link l):
         guile> (cog-incoming-set x)
         (#<link[2 sti:(0,0) tv:(0.000000,0.000000) <[3 abc],[3 def]>]>)
         guile> (cog-incoming-set y)
         (#<link[2 sti:(0,0) tv:(0.000000,0.000000) <[3 abc],[3 def]>]>)

         ; Verify that the both incoming sets are really one and the
         ; same link:
         guile> (equal? (cog-incoming-set x) (cog-incoming-set y))
         #t

         ; The returned values are lists, and not singleton atoms.
         ; Thus, the incoming set of x is a list containing l:
         guile> (equal? (cog-incoming-set x) (list l))
         #t

         ; Verify that the returned value is a true list:
         guile> (list? (cog-incoming-set x))
         #t


== cog-atom handle
      Reference the atom identified by the integer-valued handle
== cog-handle atom
      Return the handle (which is an integer) of the atom

      Example:
         ; Create two atoms, and get thier handles:
         guile> (define x (cog-new-node 'ConceptNode "abc"))
         guile> (define y (cog-new-node 'ConceptNode "def"))
         guile> (cog-handle x)
         113
         guile> (cog-handle y)
         114

         ; Get the atom corresponding to handle number 114
         guile> (cog-atom 114)
         #<node[3:def] sti:(0,0) tv:(0.000000,0.000000)>

         ; Verify that handles are truly integers
         guile> (integer? x)
         #f
         guile> (integer? (cog-handle x))
         #t


== cog-new-stv mean confidence
      Create a SimpleTruthValue with the given mean and confidence.
      Unlike atoms, simple truth values are ephemeral: they are
      automatically garbage-collected when no longer needed.

      Throws errors if mean and confidence are not floating-point
      values.
      Example:
          ; Create a new simple truth value:
          guile> (cog-new-stv 0.7 0.9)

== cog-tv? exp
      Return #t if exp is a truth value, else return #f

      Example:
         ; Define a node
         guile> (define x (cog-new-stv 0.7 0.9))
         guile> (define y (+ 2 2))
         guile> (cog-tv? x)
         #t
         guile> (cog-tv? y)
         #f


== cog-tv atom
      Return the truth-value of the atom. 

      Example:
         ; Define a node
         guile> (define x 
                   (cog-new-node 'ConceptNode "abc" 
                      (cog-new-stv 0.2 0.5)))
         guile> (cog-tv x)
         (stv 0.2 0.5)
         guile> (cog-tv? (cog-tv x))
         #t


== cog-map-type proc type
      Call proceedure proc for each atom in the atomspace that is of 
      type type. If proc returns any value other than #f, then the 
      iteration is terminated.

      Example:
         ; define a function that prints the atoms:
         guile> (define (prt-atom h) (display h) #f)
         guile> (cog-map-type prt-atom 'ConceptNode)


Example utilities
-----------------
Below follow some examples, in the form of utilities.

== Load scheme data from a file

To load scheme code from a file, simply make sure the first 3 characters
of the file are "scm" followed by a carraige return. Then, at the shell
prompt, simply execute the command:

  cat filename | telnet localhost 17001

This assuses the scheme code is in "filename", that the cogserver is
running on "localhost", and is listening on port 17001 (which is the
default port for the cogserver).

== Delete a list of atoms:

   (define (killall lst)
           (if (null? lst)
               '()
               (cons (cog-delete (car lst))
                     (killall (cdr lst)))))




ToDo
----
-- support readline/editline (uparrows, etc.) on input.

-- change cog-delete to also accept a list of atoms 
-- change cog-delete to return null, not #t (?why?)


