
               Memcachedb-based persistent storage
               -----------------------------------
                   Linas Vepstas      June 2008

This is an experimental prototype for opencog persistence, making use
of the memcache API, and the memcachedb daemon.  The goal of this 
prototype is to explore a simple distrubted persistence scheme, focusing
on performance. This is in contrast to the SQL perstance mechanism, 
which currently has underwhelming performance.

Actually, its a pre-proptotype, nothing works yet.

Memcache overview
-----------------
Memcache was originally developed as a system for high-speed caching of 
precomputed data used in high-volume webserver applications. It consists
of three parts: memcached, a daemon that performs the actual caching,
the memcache protocol, a network protocol of rather simple caching
commands (get, set, delete, etc.) and various libraries that emit the
network protocol to talk to the caching daemons.  There are two
libraries for C/C++: libmemcache (deprecated) and libmemcached. 
There are also client-side libraries for other programming langauges.

Persistence is obtained via memcachedb, a daemon which responds to the 
memcache protocol, and uses the Sleepycat/Berkeley DB to provide 
persistant storage for the cached objects.

Installation
------------
Need to install "memcachedb". This is a very simple database server that
talks the memcached protocol. The "start-db-server.sh" is a simple shell
to start the server. Edit this script as needed. In particular, change
the database name, as needed.

Testing the install
-------------------
The "sniff.cc" program provides a very simple example of programming with
the memcached API. This rpogram should run and work correctly.


Mapping AtomSpace to key-value pairs
------------------------------------
The mapping of atoms to key-value pairs is in the form of a file-system
path. The root is the integer value of the handle. This is followed by
a slash, and then a named field, appropriate for that atom.  

   Key                   Value                                 Format
   ---                   -----                                 ------
   Handle/"type"         atom type                             int
   Handle/"name"         Node string name (absent for links)   string
   Handle/"stv/mean"     simple truth value mean               double
   Handle/"stv/count"    simple truth value count              double
   Handle/"edges/arity"  arity, for links                      int
   Handle/"edges/0"      Handle of 0'th outgoing link          int
   Handle/"edges/1"      Handle of 1'th outgoing link          int
   
At this time, ints are assumed to be 32-bit ints. Memcache stores the
lengths of both keys and values, this should be adequeate to easily 
expand for 64-bit handles in the future, while also remaining backwards
compatible.

The above mapping, while being fairly orthogonal, is not very effcient
for either storage nor for protocol overhead. Thus, the code uses a 
slightly modified version, as below.

   Key                   Value                                 Format
   ---                   -----                                 ------
   Handle/"type"         atom type                             int
   Handle/"name"         Node string name (absent for links)   string
   Handle/"stv"          (mean, count)                         (double, double)
   Handle/"edges"        (arity, handle0, handle1, ...)        (int, int, ...)

Atoms will typically have only three of the four above: Nodes will have
type, name, and stv, while Links will have type, edges and stv. If/when
other kinds of TruthValue are supported, those will not be stored under
"stv", but rather thier own paths.

