/*
 * ForeachWord.h
 *
 * Implements a collection of iterators for running over the multiple
 * parses of a sentence, the multiple word-instances of a parse, and so
 * on. The goal here is that these iterators hide the structural detail
 * of the opencog representation of sentences, pares, and so on. Thus,
 * if (when?) the opencog representation changes, then only this file
 * needs to be adjusted, instead of the broad sweep of algorithms.
 *
 * Copyright (c) 2008 Linas Vepstas <linas@linas.org>
 */

#ifndef OPENCOG_FOREACH_WORD_H
#define OPENCOG_FOREACH_WORD_H

#include <Atom.h>
#include <ForeachChaseLink.h>
#include <FollowLink.h>
#include <Node.h>

namespace opencog {

/**
 * Call the callback for each parse in a sentence.  The argument handle
 * is presumed to identify  a SentenceNode, which is linked to parses
 * via a ParseLink:
 *
 *    ParseLink
 *        ParseNode "parse_2" strength=0.8 confidence=0.5
 *        SentenceNode "sentence_22"
 */
template<class T>
inline void foreach_parse(Handle h, bool (T::*cb)(Handle), T *data)
{
	foreach_reverse_binary_link(h, PARSE_LINK, cb, data);
}

/**
 * foreach_word_instance --
 * Call the callback for every word-instance in a parse. The argument
 * handle is presumed to identify a specific parse. Each word-instance
 * in the parse is linked to it via a ParseInstanceLink:
 *
 *    ParseInstanceLink
 *       ConceptNode "bark_169"
 *       ConceptNode "parse_3"
 */
template <class T>
inline void foreach_word_instance(Handle h, bool (T::*cb)(Handle), T *data)
{
	foreach_reverse_binary_link(h, PARSE_INSTANCE_LINK, cb, data);
}

/**
 * foreach_word_sense_of_inst --
 * Call the callback for each word-sense associated with a word-instance
 * The argument handle is presumed to identify a word instance, which is
 * linked to word senses via an InheritanceLink:
 *
 *   InheritanceLink strength=0.9 confidence=0.1
 *      ConceptNode "bark_144"
 *      WordSenseNode "bark_sense_23"
 *
 * The above link struct is generated by MihalceaLabel.cc, and any
 * changes there should be mirrored here.
 *
 * The callback has two handle arguments: the first argument will
 * contain the handle of the word-sense; the second arg will contain the
 * handle of the link making up the pair.
 */
template<typename T>
class PrivateUseOnlyEachSense
{
	public:
		bool (T::*user_cb)(Handle, Handle);
		T *user_data;
		bool sense_filter(Handle h, Handle l)
		{
			// Rule out relations that aren't actual word-senses.
			Node *sense = dynamic_cast<Node *>(TLB::getAtom(h));
			if (!sense || sense->getType() != WORD_SENSE_NODE) return false;

			return (user_data->*user_cb)(h, l);
		}
};

template<typename T>
inline void foreach_word_sense_of_inst(Handle h, bool (T::*cb)(Handle, Handle), T *data)
{
	PrivateUseOnlyEachSense<T> es;
	es.user_cb = cb;
	es.user_data = data;
	foreach_binary_link(h, INHERITANCE_LINK, &PrivateUseOnlyEachSense<T>::sense_filter, &es);
}

/**
 * Given a dictionary word, call the callback for each word sense
 * associated with that dictionary word, for all parts-of-speech.
 * The argument is presumed to point at a specific dictionary word.
 *
 * Each dictionary-word is assumed to be linked to word senses via
 *
 *    <WordSenseLink>
 *       <WordNode name="bark" />
 *       <ConceptNode name="bark_sense_23" />
 *    </WordSenseLink>
 *
 */
template <class T>
inline void foreach_dict_word_sense(Handle h, bool (T::*cb)(Handle), T *data)
{
	foreach_binary_link(h, WORD_SENSE_LINK, cb, data);
}

/**
 * foreach_dict_word_sense_pos --
 * Given a dictionary word, call the callback for each word sense
 * associated with that dictionary word, for the indicated parts-of-speech.
 * The argument is presumed to point at a specific dictionary word.
 *
 * Each dictionary-word is assumed to be linked to word senses via
 *
 *    WordSenseLink
 *       WordNode "bark"
 *       ConceptNode "bark_sense_23"
 *
 * Each word-sense is assumed to be linked to a part-of-speech via
 *
 *    PartOfSpeechLink
 *       ConceptNode "bark_sense_23"
 *       ConceptNode "noun"
 *
 */
// The PrivateUseOnlyPOSFilter class should be local scope to
// foreach_dict_word_sense_pos() only, but C++ doesn't allow this. :-(
// This class is not for general, public use!
template <typename T>
class PrivateUseOnlyPOSFilter
{
	public:
		bool (T::*user_cb)(Handle);
		T *user_data;
		const std::string *desired_pos;
		bool pos_filter(Handle h)
		{
			Atom *word_sense = TLB::getAtom(h);

			// Find the part-of-speech for this word-sense.
			FollowLink fl;
			Atom *a = fl.follow_binary_link(word_sense, PART_OF_SPEECH_LINK);
			Node *n = dynamic_cast<Node *>(a);
			std::string sense_pos = n->getName();

			// If there's no POS match, skip this sense.
			if (desired_pos->compare(sense_pos)) return false;

			// If we are here, there's a match, so call the user callback.
			return (user_data->*user_cb)(h);
		}
};

template <typename T>
inline void foreach_dict_word_sense_pos(Handle h, const std::string &pos,
                                        bool (T::*cb)(Handle), T *data)
{
	PrivateUseOnlyPOSFilter<T> pf;
	pf.user_cb = cb;
	pf.user_data = data;
	pf.desired_pos = &pos;
	foreach_binary_link(h, WORD_SENSE_LINK,
	                         &PrivateUseOnlyPOSFilter<T>::pos_filter, &pf);
}

/**
 * get_part_of_speech - return part of speech for indicated atom.
 * @handle:  handle of a concept (word-instance or word-sense node).
 *
 * Return the part-of-speech for the indicated concept (word-instance
 * or word-sense node). This is just a predicate, looking for a link
 * type of "PartOfSpeech", and returning the second element of that
 * link, (which is assumed to be a node).
 *
 * Each word-instance is assumed to be linked to a part-of-speech via
 *
 *    PartOfSpeechLink
 *       ConceptNode "bark_169"
 *       DefinedLinguisticConceptNode "noun"
 *
 * Word-sense nodes are similarly linked:
 *
 *    PartOfSpeechLink
 *       WordSenseNode "bark_sense_2"
 *       ConceptNode "noun"
 */
inline const std::string& get_part_of_speech(Handle h)
{
	static std::string empty;
	Atom * word_instance = TLB::getAtom(h);

	// Find the part-of-speech for this word instance.
	FollowLink fl;
	Atom *inst_pos = fl.follow_binary_link(word_instance, PART_OF_SPEECH_LINK);
	Node *n = dynamic_cast<Node *>(inst_pos);
	if (n == NULL) return empty;
	return n->getName();
}

/**
 * Return the dictionary-word correspondng to a given word-instance.
 *
 * Each word-instance is assumed to be link to a single WordNode via
 * a ReferenceLink:
 *
 *    ReferenceLink
 *      ConceptNode "bark_169"
 *      WordNode "bark"
 */
inline Handle get_dict_word_of_word_instance(Handle h)
{
	Atom *word_instance = TLB::getAtom(h);
	FollowLink fl;
	Atom *dict_word = fl.follow_binary_link(word_instance, REFERENCE_LINK);
	return TLB::getHandle(dict_word);
}

/**
 * Follow sense edges.
 * It is assumed that the incoming handle is a (inst,sense) pair.
 * The callback is invoked for each edge, passing the far pair
 * as the first argument, and the edge itself as the second argument.
 */
template <typename T>
inline bool
foreach_sense_edge(Handle h,
                   bool (T::*cb)(Handle, Handle), T *data)
{
	return foreach_unordered_binary_link(h, COSENSE_LINK, cb, data);
}


/**
 * For each word-instance, loop over all syntactic relationships
 * (i.e. _subj, _obj, _nn, _amod, and so on). For each relationship,
 * call the indicated callback. The callback is passed the relation
 * name, and the two members of the relation.
 *
 * It is assumed that the relex relationships are structured as follows:
 *
 *    "The outfielder caught the ball."
 *    <!-- _subj (<<catch>>, <<outfielder>>) -->
 *    EvaluationLink
 *       DefinedLinguisticRelationshipNode "_subj"
 *       ListLink
 *          ConceptNode "catch_instance_23"
 *          ConceptNode "outfielder_instance_48"
 *
 * It is assumed that the passed handle indicates the first word
 * instance in the relationship.
 */
// The PrivateUseOnlyRelationFinder class should be local scope to
// foreach_relex_relation() only, but C++ doesn't allow this. :-(
// This class is not for general, public use!
template <typename T>
class PrivateUseOnlyRelexRelationFinder
{
	private:
		Atom *listlink;
		bool look_for_eval_link(Handle h)
		{
			Atom *a = TLB::getAtom(h);
			if (a->getType() != EVALUATION_LINK) return false;

			// If we are here, lets see if the first node is a ling rel.
			Link *l = dynamic_cast<Link *>(a);
			if (l == NULL) return false;

			a = l->getOutgoingAtom(0);
			Node *n = dynamic_cast<Node *>(a);
			if (n == NULL) return false;
			if (n->getType() != DEFINED_LINGUISTIC_RELATIONSHIP_NODE) return false;

			// OK, we've found a relationship. Get the second member of
			// the list link, and call the user callback with it.
			const std::string &relname = n->getName();

			l = dynamic_cast<Link *>(listlink);
			const std::vector<Handle> outset = l->getOutgoingSet();

			// First arg must be first (avoid reporting twice with swapped order).
			if (first_arg != outset[0]) return false;

			(user_data->*user_cb)(relname, outset[0], outset[1]);
			return false;
		}
		
	public:
		Handle first_arg;
		bool (T::*user_cb)(const std::string &, Handle, Handle);
		T *user_data;

		bool look_for_list_link(Handle h)
		{
			Atom *a = TLB::getAtom(h);
			if (a->getType() != LIST_LINK) return false;
			listlink = a;

			// If we are here, lets see if the list link is in eval link.
			foreach_incoming_handle(h, &PrivateUseOnlyRelexRelationFinder::look_for_eval_link, this);
			return false;
		}
};

template <typename T>
inline void
foreach_relex_relation(Handle h,
                       bool (T::*cb)(const std::string &, Handle, Handle), T *data)
{
	PrivateUseOnlyRelexRelationFinder<T> rrf;
	rrf.user_cb = cb;
	rrf.user_data = data;
	rrf.first_arg = h;
	foreach_incoming_handle(h, &PrivateUseOnlyRelexRelationFinder<T>::look_for_list_link, &rrf);
}

/**
 * Return the word-instance correspondng to a given word-sense-link
 *
 * Each word-sense-link is assumed to be link a word instance to a
 * sense node:
 *
 *    InheritanceLink
 *      ConceptNode "bark_144"
 *      WordSenseNode "bark_sense_23"
 */
inline Handle get_word_instance_of_sense_link(Handle h)
{
	const Link * sense_link = dynamic_cast<const Link *>(TLB::getAtom(h));
	std::vector<Handle> v = sense_link->getOutgoingSet();
	return v[0];
}

}

#endif /* OPENCOG_FOREACH_WORD_H */

